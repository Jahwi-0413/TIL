# 0220

- Race Condition

  - critical section
  - sepaphore & mutex

- Paging & Segmentation

  - 가상 메모리
  - 메모리 단편화
  - paging
  - segmentation

- Debounce & Throttle
- Jira Component

<br/>

## 1. Race Condition

---

- 두 개 이상의 프로세스 또는 스레드가 하나의 자원에 접근하기 위해 경쟁하는 상태

### critical section

- 통제가 필요한 영역

- race condition 해결 조건 3가지

1. mutual exclusion (상호배제)<br/>
   어떤 프로세스가 임계 영역 사용시 다른 프로세스는 임계영역에 들어가지 못하도록 함
2. progress (진행)<br/>
   임계영역을 사용하는 프로세스가 없을때는 사용할 수 있어야 함
3. bounded waiting (한정 대기)<br/>
   무한 대기하는 프로세스가 없어야 함

### sepaphore (세마포어)

임계영역에 접근할 수 있는 프로세스 수를 정해두는 기법

### mutex (뮤텍스)

임계영역에 접근하는 프로세스는 권한을 얻어서 접근하도록 하는 기법

<br/>

## 2. Paging & Segmentation

---

프로그램의 용양이 메인 메모리보다 큰 문제를 해결하기 위함

### 가상 메모리

실제 물리 메모리와 논리 메모리 개념을 분리한 것. 가상 주소를 실제 메모리 주소로 변환해주는 장치(MMU)를 사용함.

장점

- 실제 메모리보다 더 큰 메모리 공간 사용 가능
- 가상 주소를 이용해 논리적인 연속성
- 물리 메모리 주소 공간을 몰라도 연산 가능

### 메모리 단편화

메모리를 조각내서 할당해 실제로는 메모리가 충분하지만 할당이 불가능한 상태가 발생할 수 있다.

- 내부 단편화<br/>
  메모리 할당시 필요한 양보다 더 큰 메모리가 할당되어 메모리가 낭비되는 것
- 외부 단편화<br/>
  할당된 메모리 사이에 사용하지 않는 메모리 공간이 생기는것,<br/>
  총 메모리 공간은 충분하지만 실제로는 할당할 수 없는 상황

해결방안 → 페이징, 세그멘테이션

### paging (페이징)

프로세스를 페이지로 나눠서 메모리에 적재하는 방법

물리 메모리는 프레임으로 나눠서 페이지 테이블을 이용해 페이지와 프레임을 매핑시키는 방식

페이지는 순서에 상관없이 프레임과 매핑됨

페이징 테이블에는 각 페이지의 메인 메모리 시작 주소가 있음

### segmentation (세그멘테이션)

가상 메모리를 크기가 다른 논리적 단위로 분할한 것이다. 이 논리적 단위를 세그먼트라고 한다.

페이징과 마찬가지로 세그먼트 테이블을 이용해 메인 메모리와 매핑한 정보를 관리한다.

<br/>

## 3. Debounce & Throttle

---

시간에 따라 함수 실행을 제어하는 것

### debounce

여러개의 순차적인 호출을 하나의 호출로 그룹화 하는것

ex) input의 onChange<br/>
-> 자음 모음 하나마다 입력 이벤트를 처리하는것이 아니라<br/>
글자 하나를 다 입력해야 이벤트를 처리하도록 조절하는것

https://codepen.io/dcorb/pen/GZWqNV

<br/>

### throttle

이벤트를 일정 시간동안 한번만 실행하도록 하는 것

ex) 무한 스크롤

<br/>

### debounce vs throttle

debounce는 입력이 끝날때까지 무한정으로 기다림<br/>
throttle은 입력이 시작되면 일정 주기로 계속 실행함

## 4. Jira Component

---

담당자/팀이 정해진 기능/범위가 있을 때<br/>
default assignee를 지정하고 싶을때
